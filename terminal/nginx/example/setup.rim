# terminal/nginx/example/setup
' LeonardPauli/docs
	Created by Leonard Pauli, 24 mar 2018

prerequisites:
	see setup-simple."simplest server setup"
	// optional: see setup-simple."creating dev-mode setup"

- ssl using self-signed cert:
	- make main nginx.conf editable
		- docker-compose exec nginx sh -c "cat /etc/nginx/nginx.conf" > nginx.conf // copy it from inside the container
		- edit Dockerfile: // insert close to "layer nginx config"
			COPY nginx.conf /etc/nginx/nginx.conf
		- vi nginx.conf // comment out ssl_session_cache, because it conflicts with later settings ("... conflicts with already declared size ...")

	- mkdir ssl && echo ssl >> .gitignore // key should be secret, and not in source version control / git (it only is in this example as an example)
	- ssl.example.setup."self signed certificate"
		FOLDER: "ssl"
		DOMAINS: "localhost,127.0.0.1,::1,my-app.dev"
	- nginx.ssl.base.setup
		default.conf should then have two server blocks (80 and 443), both ending with:
			root /usr/src/app/;
			try_files /index.html =404;
	- nginx.security."use recommended security headers:"
	- make ssl folder available in container
		- edit Dockerfile: // insert close to "layer nginx config"
			VOLUME /etc/nginx/ssl
		- edit docker-compose.yaml: // insert after + at same level as "build" block
			volumes:
				- ./ssl:/etc/nginx/ssl
	- expose https port (443, in addition to http port, 80)
		- edit Dockerfile:
			EXPOSE 80 443
		- edit docker-compose.yaml:
			port: ["80:80", "443:443"]

	- docker-compose up --build -d
	- test it at localhost
		- docker-compose logs // if not showing up
	- test it at https://localhost
		should say "Not secure"


- ssl using cert-signing-request and own CA:
	- CA.local-dev.create-and-install {NAME: "nginx.example test CA"}
	- cert.create-using-CA {USERFACINGNAME: "my-app.dev cert", DOMAINS: "localhost", "127.0.0.1", "::1", "my-app.dev"}
	- use new files
		- move (crt, key) to ssl/ and rename to own-ca-signed.(crt, key)
		- vi nginx/default.conf -c ":%s/selfsigned/own-ca-signed/g" -c ":wq" // replace selfsigned with own-ca-signed
	- rebuild and test it
		now you should get the green lock

		
	thereafter:
		- edit hosts file to get https://my-app.dev
		- force-https
		- auto-renew cert with your CA as an external service
		- switch out your CA with a recognizable (eg. lets-encrypt)
		- change auto-renew script to work with its service

	then:
		- secure production environment:
			// see https://github.com/voxpupuli/hiera-eyaml
			// see terminal/pgp-workflow
			- generate server.key.(pub and priv) on server once during setup by trusted sysadmin
			- only copy server.key.pub, and save it to git
			- discard all access to server (including server.key.priv)
				// it will then only be changed using git/CI system
				// if now core setup is needed, only option is to discard and recreate the server
				// Possible to save backup access in case inspection needed (in case of attack)? if so its use should be clearly noted.
			- upload server.key.priv to 
			- secret production files
				- eg. .env.prod and ssl.key.prod
				- encrypt using server.key.pub, during dev
				- decrypt using server.key.priv, on server
				' should only be readable by prod server, but writable by devs
						- only reach prod after CI and peer-review
						- extra flag if secure stuff changed
						- only pass master CI if last commit signed by trusted devs
					encrypted could be stored in git
						(but keeping them org-public rather than world-public can't be that bad if quantum computers manage to crack all encryption? :))
							(Nah, bigger problems then.)


notes: // TODO: move to terminal/ssl
	- CA.local-dev.create-and-install {NAME: "nginx.example test CA"}
		// https://deliciousbrains.com/ssl-certificate-authority-for-local-https-development/
		- key.private.create: openssl genrsa -out myCA.key 2048
			// use -des3 (instead of -nodes) to encrypt key with passphrase (store in 1password or similar)
			// just to prevent anyone that happens to come over the file to create certs trusted by your computer
			// though if they get the file, there will be bigger issues, and it will be limited to SSL (see below), and only used for local development...
		- cert.root.create: openssl req -x509 -new -nodes -key myCA.key -sha256 -days 365 -out myCA.pem -subj "/CN=NAME"
		- CA.cert.root.install
			- on OSX: // (possibly requires browser restart)
				- open /Applications/Utilities/Keychain\ Access.app/
				- File -> Import Items... (⌘⇧I)
				- search (⌘⌥F): NAME
				- double click it, expand trust section, change SSL to Always trust, close, enter password

	- cert.create-using-CA {USERFACINGNAME: "my-app.dev cert", DOMAINS: "localhost", "127.0.0.1", "::1", "my-app.dev"}
		- a signing-request
			- key.private.create: openssl genrsa -out domain.key 2048
			- signing-request.create: openssl req -new -key domain.key -out domain.csr -subj "/CN=USERFACINGNAME"
		- send it + domain names to CA for signed cert creation // you keep the private key?
			- config.create: vi domain.ext // TODO: if this is the same kind of file as in self-signed... DRY it up?
				authorityKeyIdentifier=keyid,issuer
				basicConstraints=CA:FALSE
				keyUsage = digitalSignature, nonRepudiation, keyEncipherment, dataEncipherment # sure of all of those?
				subjectAltName = @alt_names

				[alt_names]
				DNS.1 = DOMAINS.0
				DNS.2 = DOMAINS.1
				# etc
			- CA.cert.create with req: openssl x509 -req -sha256 -days 365 \
				-CA myCA.pem -CAkey myCA.key -CAcreateserial \
				-extfile domain.ext -in domain.csr -out domain.crt
