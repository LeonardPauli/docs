# terminal/nginx/example/setup
' LeonardPauli/docs
	Created by Leonard Pauli, 24 mar 2018

prerequisites:
	see setup-simple."simplest server setup"
	// optional: see setup-simple."creating dev-mode setup"

- ssl using self-signed cert:
	- make main nginx.conf editable
		- docker-compose exec nginx sh -c "cat /etc/nginx/nginx.conf" > nginx.conf // copy it from inside the container
		- edit Dockerfile: // insert close to "layer nginx config"
			COPY nginx.conf /etc/nginx/nginx.conf
		- vi nginx.conf // comment out ssl_session_cache, because it conflicts with later settings ("... conflicts with already declared size ...")

	- mkdir ssl && echo ssl >> .gitignore // key should be secret, and not in source version control / git (it only is in this example as an example)
	- ssl.example.setup."self signed certificate"
		FOLDER: "ssl"
		DOMAINS: "localhost,my-app.localhost,local.my-app.com"
		// see "custom localhost domain name"
	- nginx.ssl.base.setup
		default.conf should then have two server blocks (80 and 443), both ending with:
			root /usr/src/app/;
			try_files /index.html =404;
	- nginx.security."use recommended security headers:"
	- make ssl folder available in container
		- edit Dockerfile: // insert close to "layer nginx config"
			VOLUME /etc/nginx/ssl
		- edit docker-compose.yaml: // insert after + at same level as "build" block
			volumes:
				- ./ssl:/etc/nginx/ssl
	- expose https port (443, in addition to http port, 80)
		- edit Dockerfile:
			EXPOSE 80 443
		- edit docker-compose.yaml:
			port: ["80:80", "443:443"]

	- docker-compose up --build -d
	- test it at localhost
		- docker-compose logs // if not showing up
	- test it at https://localhost
		should say "Not secure"


- ssl using cert-signing-request and own CA:
	- terminal/ssl/using-ca.CA.local-dev.create-and-install {NAME: "nginx.example test CA"}
	- terminal/ssl/using-ca.cert.create-using-CA {USERFACINGNAME: "my-app.dev cert", DOMAINS: "localhost", "my-app.localhost", "local.my-app.com"}
	- use new files
		- move (crt, key) to ssl/ and rename to own-ca-signed.(crt, key)
		- vi nginx/default.conf -c ":%s/selfsigned/own-ca-signed/g" -c ":wq" // replace selfsigned with own-ca-signed
	- rebuild and test it
		now you should get the green lock


- see nginx.ssl.force-https
- see nginx.ssl.catch-all


- custom localhost domain name:
	' note
		my-app.dev was a common pattern before google bought it as a gTLD
			(and enforced https (good but not when testing own https redirect...))
		localhost -> 127.0.0.1 (by default)
		*.local -> reserved by "Apple Bonjour" in osx
		*.localhost -> 127.0.0.1 (by default in many os:es, but not always, though it's reserved to not be registered as an TLD, + clear (but many chars), so relatively good choice, could possibly be wrongly used by something else)
		local.my-app.com -> 127.0.0.1 (configurable in /etc/hosts, probably best if you already own my-app.com)
		(make sure the name you choose is in your ssl cert (self-signed for dev / local))
	- see network.hosts-file.edit: // add line
		127.0.0.1 local.my-app.com
	- make server respond to it: vi nginx/default.conf // where just my-app.localhost was before
		server_name local.my-app.com my-app.localhost;




	thereafter:
		- auto-renew cert with your CA as an external service
		- switch out your CA with a recognizable (eg. lets-encrypt)
		- change auto-renew script to work with its service

	then:
		- secure production environment:
			// see https://github.com/voxpupuli/hiera-eyaml
			// see terminal/pgp-workflow
			- generate server.key.(pub and priv) on server once during setup by trusted sysadmin
			- only copy server.key.pub, and save it to git
			- discard all access to server (including server.key.priv)
				// it will then only be changed using git/CI system
				// if now core setup is needed, only option is to discard and recreate the server
				// Possible to save backup access in case inspection needed (in case of attack)? if so its use should be clearly noted.
			- upload server.key.priv to 
			- secret production files
				- eg. .env.prod and ssl.key.prod
				- encrypt using server.key.pub, during dev
				- decrypt using server.key.priv, on server
				' should only be readable by prod server, but writable by devs
						- only reach prod after CI and peer-review
						- extra flag if secure stuff changed
						- only pass master CI if last commit signed by trusted devs
					encrypted could be stored in git
						(but keeping them org-public rather than world-public can't be that bad if quantum computers manage to crack all encryption? :))
							(Nah, bigger problems then.)
